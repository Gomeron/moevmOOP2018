#ifndef FIELD
#define FIELD
#include "object"
#include <vector>
#include "list"

using namespace std;

// class Object;

//--------------------------------------FIELD----------------------------------------------
class Field{
    friend class Object;
    friend class List<Object>;

    shared_ptr<Crown> crown_red;
    shared_ptr<Crown> crown_green;    

    int x_size_;
    int y_size_;
   
    char **map; //map[y][x] - access
    List<List<Object>> conts;     

public:
    Field( int x_size, int y_size   );
    ~Field();
    
    void print_field(ostream &out);
    void print_cont();
    void add_to_map(int i, int j);
    void read_file(istream &f);
    Object get_ob(int i, int j);
    int belonging_army(int i, int j);
    void check_map();
    int is_obj(int x, int y);
    int find_ob_index(int i, int j);


    char **getmap();
    List<List<Object>> getconts();

    friend istream &operator>>(istream &in, Field &fd);
    friend ostream &operator<<(ostream &out, const Field &fd);
};
//-----------------------------------------------------------------------------------------


//---------------------------------FIELD-METHODS-------------------------------------------
Field::Field( int x_size, int y_size) 
{
    x_size_ = x_size;
    y_size_ = y_size;

    cout << "Field:"<<endl    
         <<"    x_size = " << x_size_<< endl
         <<"    y_size = " << y_size_<<endl; 
    
//  create a clean map
    int i = 0;
    map = new char*[y_size]; 
   
    for(int i = 0; i < y_size_; i++){ 
        map[i] = new char[x_size_];
    }
    for(int i = 0; i < x_size_; i++){
        for(int j = 0; j < y_size_; j++){
            map[i][j] = '.';
        }
    }
// create containers for armies`
    i = 0;
    while(i++ < 2){
        List<Object> *some = new List<Object>;
        conts.insert_tail(*some);
        // conts.push_back(some);
    }
}

void Field::add_to_map(int i, int j) 
    { map[i][j] = 'o'; }

Field::~Field(){
    cout << "~Field:"<<endl;     
    int count_cont = 0;
    for(auto &cont: conts){ 
        for(auto &obj : cont.get()){ 
            cout << count_cont << ": "; obj.get().print_ob_simple();
        }
        count_cont++;
    }
}

int Field::is_obj(int i, int j)
{
    if (map[j][i] = 'o') return 1;
    if (map[j][i] = 'x') return 0;
    else return -1; // not found
    
}

Object Field::get_ob(int i, int j) //map[j][i]-ok
{
    for(auto &cont: conts){ 
        int count = 0; 
        for(auto &elem : cont.get()){ 
            if(elem.get().getx() == i && elem.get().gety() == j) {
                Object o = conts[elem.get().army()][count]; 
                return o;
            }
            count++;
        }
    }
    // return ; // not found
}

int Field::find_ob_index(int i, int j) //map[j][i]-ok
{
    for(auto &cont: conts){ 
        int count = 0; 
        for(auto &elem : cont.get()){ 
            if(elem.get().getx() == i && elem.get().gety() == j) 
                return count; 
            count++;
        }
    }
    return -1; // not found
}

int Field::belonging_army(int i, int j)
{
    int army = 0;
    for(auto &cont: conts){ 
        for(auto &obj : cont.get()){ 
            if(obj.get().getx() == i && obj.get().gety() == j)  
                return army;
        }
        army++;
    }
    return -1; //not found
}

void Field::check_map()
{
    for(auto &cont: conts){ 
        for(auto &obj : cont.get()){ 
            if(obj.get().gethp() <= 0) 
                map[obj.get().gety()][obj.get().getx()] = 'x';
        }
    }
}

void Field::print_cont()
{
    int count_cont = 0;
    for(auto &cont: conts){ 
        for(auto &obj : cont.get()){ 
            cout << count_cont << ": "; obj.get().print_ob_simple();
        }
        count_cont++;
    }
}

void Field::print_field(ostream &out)
{   
    check_map();
    out <<endl;
    for(int i = 0; i < y_size_; i++){ if(i==0) out << "  "; out <<  i; } out << endl;        
    for(int i = 0; i < y_size_; i++){ 
        if(i==0 || i == y_size_-1) {
            if(i==0) out << "  ";
            out << "+"; 
        }
        else out << "-"; 
    }out << endl;   
    for(int i = 0; i < y_size_; i++){
        out << i << "|";
        for(int j = 0; j < x_size_; j++){
            int belong = belonging_army(j,i);
            switch(belong){
                case 0:
                    out << "\x1b[31m"<<map[i][j]<<"\x1b[0m";
                    break;
                case 1:
                    out << "\x1b[32m"<<map[i][j]<<"\x1b[0m";
                    break;
                default:
                    out << map[i][j];
                    break;
            }
        }
        out<< "|" <<endl;
    }
    for(int i = 0; i < y_size_; i++){ 
        if(i==0 || i == y_size_-1) {
            if(i==0) out << "  ";
            out << "+"; 
        }
        else out << "-"; 
    }out<<endl;   
    for(int i = 0; i < y_size_; i++){ if(i==0) out << "  "; out <<  i; } out << endl; 
    out <<endl;      
}

char **Field::getmap()
    {return map;}

List<List<Object>>Field::getconts() 
    {return conts;}

//-----------------------------------------------------------------------------------------

ostream &operator<<(ostream &out, Field &fd){
    fd.print_field(out);
    return out;
}

istream &operator>>(istream &in, Field &fd){
    int redflag = 0;
    int greenflag = 0;
    int obj_amount = 0;
    int j = 0;
    while(j < 2){  
        in >> obj_amount; 
        int i = 0;
        while (i++ < obj_amount){ 
            Object* ob;
            if (j == 0) {                            
                if(!redflag) {fd.crown_red = make_shared<Crown>("red"); redflag = 1;}
                ob = new Object(fd.crown_red, in);
            }
            else if(j == 1){  
                if(!greenflag) {fd.crown_green = make_shared<Crown>("green"); greenflag = 1;}
                ob = new Object(fd.crown_green, in);
            }
            fd.getconts()[j].insert_tail(*ob); // add an object to j container   
            fd.add_to_map(ob->gety(), ob->getx()); // mark this object on the map
        }
        j++;    
    }
// not good
    cout << "Field.\n"; 
    return in;
}

//-----------------------------------------------------------------------------------------
#endif //FIELD