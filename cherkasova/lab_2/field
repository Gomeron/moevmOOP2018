#ifndef FIELD
#define FIELD
#include "object"
#include <vector>
#include "list"

using namespace std;

// class Object;

//--------------------------------------FIELD----------------------------------------------
class Field{

    int x_size;
    int y_size;
    
    weak_ptr<Crown> crown_red;
    weak_ptr<Crown> crown_green;    

    char **map; 
    List<List<Object>> contains;     
    
    friend class Object;
    friend class List<Object>;
   
public:
    // Field( int x_size, int y_size   );
    Field(){}
    ~Field();
    
    void init(); 
    void print_field(ostream &out);
    void print_cont();
    void add_to_map(int i, int j);
    void read_file(istream &f);
    Object get_ob(int i, int j);
    int belonging_army(int i, int j);
    void check_map();
    int is_obj(int x, int y);
    int find_ob_index(int i, int j);
    void read_from_file(istream &in);
    


    char **getmap();
    List<List<Object>> getconts();

    friend istream &operator>>(istream &in, Field &fd);
    friend ostream &operator<<(ostream &out, const Field &fd);
};
//-----------------------------------------------------------------------------------------


//---------------------------------FIELD-METHODS-------------------------------------------
void Field::init() 
{
    cout << "Field:"<<endl    
         <<"    x_size = " << x_size<< endl
         <<"    y_size = " << y_size<<endl; 
    
//  create a clean map
    int i = 0;
    map = new char*[y_size]; 
   
    for(int i = 0; i < y_size; i++){ 
        map[i] = new char[x_size];
    }
    for(int i = 0; i < x_size; i++){
        for(int j = 0; j < y_size; j++){
            map[i][j] = '.';
        }
    }
// create containers for armies`
    i = 0;
    while(i++ < 2){
        List<Object> some;
        contains.insert_tail(some);
        // contains.push_back(some);
    }
}

void Field::add_to_map(int i, int j) 
    { map[i][j] = 'o'; }

Field::~Field(){
    cout << "~Field:"<<endl;     
    int count_cont = 0;
    for(auto &cont: contains){ 
        for(auto &obj : cont.get()){ 
            cout << count_cont << ": "; obj.get().print_ob_simple();
        }
        count_cont++;
    }
}

int Field::is_obj(int i, int j)
{
    if (map[i][i] = 'o') return 1;
    if (map[j][i] = 'x') return 0;
    else return -1; // not found
    
}

Object Field::get_ob(int i, int j) //map[j][i]-ok
{
    for(auto &cont: contains){ 
        int count = 0; 
        for(auto &elem : cont.get()){ 
            if(elem.get().getx() == i && elem.get().gety() == j) {
                Object o = contains[elem.get().army()][count]; 
                return o;
            }
            count++;
        }
    }
    // return ; // not found
}

int Field::find_ob_index(int i, int j) //map[j][i]-ok
{
    for(auto &cont: contains){ 
        int count = 0; 
        for(auto &elem : cont.get()){ 
            if(elem.get().getx() == i && elem.get().gety() == j) 
                return count; 
            count++;
        }
    }
    return -1; // not found
}

int Field::belonging_army(int i, int j)
{
    int army = 0;
    for(auto &cont: contains){ 
        for(auto &obj : cont.get()){ 
            if(obj.get().getx() == i && obj.get().gety() == j)  
                return army;
        }
        army++;
    }
    return -1; //not found
}

void Field::check_map()
{
    for(auto &cont: contains){ 
        for(auto &obj : cont.get()){ 
            if(obj.get().gethp() <= 0) 
                map[obj.get().gety()][obj.get().getx()] = 'x';
        }
    }
}

void Field::print_cont()
{
    int count_cont = 0;
    for(auto &cont: contains){ 
        for(auto &obj : cont.get()){ 
            cout << count_cont << ": "; obj.get().print_ob_simple();
        }
        count_cont++;
    }
}

void Field::print_field(ostream &out)
{   
    check_map();
    out <<endl;
    for(int i = 0; i < y_size; i++){ if(i==0) out << "  "; out <<  i; } out << endl;        
    for(int i = 0; i < y_size; i++){ 
        if(i==0 || i == y_size-1) {
            if(i==0) out << "  ";
            out << "+"; 
        }
        else out << "-"; 
    }out << endl;   
    for(int i = 0; i < y_size; i++){
        out << i << "|";
        for(int j = 0; j < x_size; j++){
            int belong = belonging_army(j,i);
            switch(belong){
                case 0:
                    out << "\x1b[31m"<<map[i][j]<<"\x1b[0m";
                    break;
                case 1:
                    out << "\x1b[32m"<<map[i][j]<<"\x1b[0m";
                    break;
                default:
                    out << map[i][j];
                    break;
            }
        }
        out<< "|" <<endl;
    }
    for(int i = 0; i < y_size; i++){ 
        if(i==0 || i == y_size-1) {
            if(i==0) out << "  ";
            out << "+"; 
        }
        else out << "-"; 
    }out<<endl;   
    for(int i = 0; i < y_size; i++){ if(i==0) out << "  "; out <<  i; } out << endl; 
    out <<endl;      
}

char **Field::getmap()
    {return map;}

List<List<Object>>Field::getconts() 
    {return contains;}

//-----------------------------------------------------------------------------------------

ostream &operator<<(ostream &out, Field &fd){
    fd.print_field(out);
    return out;
}

void Field::read_from_file(istream &in){
    int redflag = 0;
    int greenflag = 0;
    int obj_amount = 0;
    int j = 0;
    
    in >> *this;
    this->init();
    
    while(j < 2){  
        in >> obj_amount; 
        int i = 0;
        while (i++ < obj_amount){ 
            Object *ob;
            if (j == 0) {                            
                if(!redflag) {
                    // this->crown_red.lock() = make_shared<Crown>("red");
                    redflag = 1;
                }
                ob = new Object(this->crown_red.lock(), in);
            }
            else if(j == 1){  
                if(!greenflag) {
                    // this->crown_green.lock() = make_shared<Crown>("green");
                    greenflag = 1;
                }
                ob = new Object(this->crown_green.lock(), in);
            }
            this->getconts()[j].insert_tail(*ob); // add an object to j container   
            this->add_to_map(ob->gety(), ob->getx()); // mark this object on the map
            cout<<"MATCh\n";
        }
        j++;    
    }
// not good
    cout << "Field.\n"; 
}

istream &operator>>(istream &in, Field &fd){
    in >> fd.x_size >> fd.y_size;
    // fd.crown_red.lock() = make_shared<Crown>("red");
    // fd.crown_green.lock() = make_shared<Crown>("green");
    return in;
}

//-----------------------------------------------------------------------------------------
#endif //FIELD